# -*- coding: utf-8 -*-
"""Atheesh_Krishnan_NA_HW3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1q_9Wj8uxNBOehYl_EYqWyWjwAzycmBUV

# Library imports
"""

import numpy as np
import matplotlib.pyplot as plt
import yfinance as yf
import pandas as pd

import numerical_utility as nu

"""# Q1"""

# Q4: Witch of Agnesi
def witch_of_agnesi(x):
    return 1 / (4 * x**2 + 1)

x_data_q4 = np.linspace(-5, 5, 20)
y_data_q4 = witch_of_agnesi(x_data_q4)

x_inter_q4 = np.linspace(-5, 5, 200)
y_inter_q4 = [nu.newton_interpolation(x_data_q4, y_data_q4, xi) for xi in x_inter_q4]


print("HW2-Q4")
for xi in [-2, -1, 0, 1, 2]:
    yi = nu.newton_interpolation(x_data_q4, y_data_q4, xi)
    print(f"f({xi}) ≈ {yi:.4f}")

plt.figure(figsize=(10, 6))
plt.plot(x_data_q4, y_data_q4, 'o', label="Given Data Points", color="blue")
plt.plot(x_inter_q4, y_inter_q4, label="Newton's Interpolation", color="green")
plt.plot(x_inter_q4, witch_of_agnesi(x_inter_q4), label="Witch of Agnesi Function", color="red", linestyle="--")
plt.xlabel("X")
plt.ylabel("Y")
plt.title("Q4: Interpolation of the Witch of Agnesi Function")
plt.legend()
plt.grid(True)
plt.show()

# Q6
x_data_q6 = [1, 0, -2, 3, -1]
y_data_q6 = [-2, -1, -56, 4, -16]

x_inter_q6 = np.linspace(min(x_data_q6), max(x_data_q6), 200)
y_inter_q6 = [nu.newton_interpolation(x_data_q6, y_data_q6, xi) for xi in x_inter_q6]

print("\nHW2-Q6")
for xi in [-2, -1, 0, 1, 2]:
    yi = nu.newton_interpolation(x_data_q6, y_data_q6, xi)
    print(f"f({xi}) ≈ {yi:.6f}")

plt.figure(figsize=(10, 6))
plt.plot(x_data_q6, y_data_q6, 'o', label="Given Data Points", color="blue")
plt.plot(x_inter_q6, y_inter_q6, label="Newton's Interpolation", color="green")
plt.xlabel("X")
plt.ylabel("Y")
plt.title("Q6: Interpolation of Given Points")
plt.legend()
plt.grid(True)
plt.show()

"""# Q2"""

def plot_interpolations(x_pts, y_pts, e):
    y_err = y_pts.copy()
    y_err[4] += e

    xy_points = list(zip(x_pts, y_err))
    x_seq = np.linspace(min(x_pts), max(x_pts), 1000)

    # lagrange
    P_lagrange = [nu.lagrange_interpolation(xy_points, x, len(x_pts) - 1) for x in x_seq]

    # cubicspline
    a, b, c, d = nu.cubic_spline_interpolation(x_pts, y_err)
    P_cubicspline = [nu.evaluate_spline(x, x_pts, a, b, c, d) for x in x_seq]

    plt.figure(figsize=(10, 6))
    plt.plot(x_pts, y_err, 'o', label="Data Points (with error)", color="red")
    plt.plot(x_seq, P_lagrange, label="Lagrange Interpolation", linestyle="--", color="blue")
    plt.plot(x_seq, P_cubicspline, label="Cubic Spline Interpolation", linestyle=":", color="green")
    plt.xlabel("x")
    plt.ylabel("y")
    plt.title(f"Interpolations with ε = {e}")
    plt.legend()
    plt.grid(True)
    plt.show()

x_pts = list(range(1, 11))
y_pts = list(range(1, 11))

es = [0.1, 0.5, 1.0, -0.75]

for e in es:
    plot_interpolations(x_pts, y_pts, e)

"""### REMARKS:

We see that the cubic spline interpolation plots for the verying levels of e do not fluctuate to the extent that the langrange interpolation does. Indeed, with a higher devation of epison from 0 the interpolation plot goes out of whack and shows quite a lot of discrepancies. Also of note is the near mirror imgae like results for negative e value.

# Q5
"""

a = -5
b = 5
x_seq = np.linspace(a, b, 1000)
n_val = [5, 10, 20, 50]

def f(x):
    return 1 / (1 + x**2)

for n in n_val:
    x_pts = nu.base_points(n, a, b)
    y_pts = f(np.array(x_pts))
    xy_points = list(zip(x_pts, y_pts))

    P_n = [nu.lagrange_interpolation(xy_points, x, n) for x in x_seq]
    e = np.abs(f(x_seq) - P_n)

    plt.figure(figsize=(10, 6))
    plt.plot(x_seq, f(x_seq), label="Function f(x)", color="blue")
    plt.plot(x_seq, P_n, label=f"Interpolation P_n(x), n={n}", color="green")
    plt.plot(x_seq, e, label=f"Error |f(x) - P_n(x)|", color="red")
    plt.xlabel("x")
    plt.ylabel("y")
    plt.legend()
    plt.grid(True)
    plt.show()

"""REMARKS:

We observe significant change in the plot as the value of n changes from 5 to 50. For the base points, initially, there is significant error surrounding x = 0 but for higher values of n they are shifted out ot the edges. Increasing n =10, improves the fit of the inteprolation in the middle, but leaves room for error in the boundaries. For n = 50 there is a huge amount of error at the boundaries. Thus the equally spaced points -5 and +5 are not ideal for higher values of n dues to the persistence of error.

# Q6
"""

for n in n_val:
    x_pts = nu.chebyshev_points(n, a, b)
    y_pts = f(np.array(x_pts))
    xy_points = list(zip(x_pts, y_pts))

    P_n = [nu.lagrange_interpolation(xy_points, x, len(xy_points) - 1) for x in x_seq]
    e = np.abs(f(x_seq) - P_n)

    plt.figure(figsize=(10, 6))
    plt.plot(x_seq, f(x_seq), label="Function f(x)", color="blue")
    plt.plot(x_seq, P_n, linestyle="--", label=f"Interpolation P_n(x), n={n}", color="green")
    plt.plot(x_seq, e, linestyle=":", label=f"Error |f(x) - P_n(x)|", color="red")
    plt.xlabel("x")
    plt.ylabel("y")
    plt.legend()
    plt.grid(True)
    plt.show()

"""REMARKS:
As n increases from 5 to 50, the interpolation plot gradually fits perfectly with the actual function plot. The errors are also naturally minimized. This provides a much better performing interpolation with significantly lower errors compared to the base point case.

# Q8
"""

aapl = yf.download('AAPL', start='2020-09-01', end='2020-09-19', actions=False)

aapl

aapl.reset_index(inplace=True)

x_data = list(range(1, len(aapl) + 1))
y_data = aapl[('Close', 'AAPL')].tolist()
xy_points = list(zip(x_data, y_data))

plt.figure(figsize=(10, 6))
plt.plot(x_data, y_data, 'o', color='black')
plt.xlabel('Business Days')
plt.ylabel('Close Price')
plt.title('AAPL Close Price')
plt.grid(True)
plt.show()

# NATURAL CUBIC SPLINE INTERPOLATION

a, b, c, d = nu.cubic_spline_interpolation(x_data, y_data)

x_inter = np.linspace(min(x_data), max(x_data), 1000)
y_inter = [nu.evaluate_spline(i, x_data, a, b, c, d) for i in x_inter]

plt.figure(figsize=(10, 6))
plt.plot(x_inter, y_inter, color='orange', label='Natural cubic spline interpolation')
plt.plot(x_data, y_data, '*', color='black', label='Actual points')
plt.xlabel('Business Days')
plt.ylabel('Close Price')
plt.title('Natural Cubic Spline Interpolation for AAPL')
plt.grid(True)
plt.legend(loc='upper left', bbox_to_anchor=(1, 1))
plt.show()

interpolated_price = nu.evaluate_spline(8.5, x_data, a, b, c, d)
print(f"Interpolated price for AAPL for day x = 8.5: {interpolated_price}")

# CLAMPED CUBIC SPLINE INTERPOLATION

der_a, der_b = 0.0, 0.0

a, b, c, d = nu.clamped_cubic_spline(x_data, y_data, der_a, der_b)

x_inter = np.linspace(min(x_data), max(x_data), 1000)
y_inter = [nu.evaluate_spline(i, x_data, a, b, c, d) for i in x_inter]

plt.figure(figsize=(10, 6))
plt.plot(x_inter, y_inter, color='red', label='Clamped cubic spline interpolation')
plt.plot(x_data, y_data, '*', color='black', label='Actual points')
plt.xlabel('Business Days')
plt.ylabel('Close Price')
plt.title('Clamped Cubic Spline Interpolation for AAPL')
plt.grid(True)
plt.legend(loc='upper left', bbox_to_anchor=(1, 1))
plt.show()

interpolated_price = nu.evaluate_spline(8.5, x_data, a, b, c, d)
print(f"Interpolated price for AAPL for day x = 8.5: {interpolated_price}")

# LAGRANGE INTERPOLATION

x_inter = np.linspace(min(x_data), max(x_data), 100)
y_inter = [nu.lagrange_interpolation(xy_points, xi, len(x_data) - 1) for xi in x_inter]

plt.figure(figsize=(10, 6))
plt.plot(x_inter, y_inter, color='blue', label='Lagrange interpolation')
plt.plot(x_data, y_data, '*', color='black', label='Actual points')
plt.xlabel('Business Days')
plt.ylabel('Close Price')
plt.title('Lagrange Interpolation for AAPL')
plt.grid(True)
plt.legend(loc='upper left', bbox_to_anchor=(1, 1))
plt.show()

interpolated_price = nu.lagrange_interpolation(xy_points, 8.5, len(x_data) - 1)
print(f"Interpolated price for AAPL for day x = 8.5: {interpolated_price}")

# NEWTON INTERPOLATION

x_inter = np.linspace(min(x_data), max(x_data), 100)
y_inter = [nu.newton_interpolation(x_data, y_data, xi) for xi in x_inter]

plt.figure(figsize=(10, 6))
plt.plot(x_inter, y_inter, color='purple', label='Newton interpolation')
plt.plot(x_data, y_data, '*', color='black', label='Actual points')
plt.xlabel('Business Days')
plt.ylabel('Close Price')
plt.title('Newton Interpolation for AAPL')
plt.grid(True)
plt.legend(loc='upper left', bbox_to_anchor=(1, 1))
plt.show()

interpolated_price = nu.newton_interpolation(x_data, y_data, 8.5)
print(f"Interpolated price for AAPL for day x = 8.5: {interpolated_price}")

"""# Q9"""

def f(x):
    return np.exp(x**2 / 10)

def f_prime(x):
    return (x / 5) * np.exp(x**2 / 10)

# (a) Hermite Interpolation on [1, 1.5]
x_a = [1, 1.5]
y_a = f(np.array(x_a))
dy_a = f_prime(np.array(x_a))

z_a, coef_a = nu.hermite_interpolation(x_a, y_a, dy_a)

print(f"(a) Hermite Polynomial Coefficients: {coef_a}")

approx_a = nu.evaluate_hermite(z_a, coef_a, 1.2)
print(f"(a) Approximation of f(1.2): {approx_a}")

x_dense_a = np.linspace(1, 1.5, 100)
f_dense_a = f(x_dense_a)
hermite_dense_a = [nu.evaluate_hermite(z_a, coef_a, xi) for xi in x_dense_a]
error_a = np.abs(f_dense_a - hermite_dense_a)

max_error_a = np.max(error_a)
print(f"(a) Maximum error: {max_error_a}")

plt.figure(figsize=(10, 6))
plt.plot(x_dense_a, error_a, label="Error", color="purple")
plt.title("(a) Error for Hermite Cubic Interpolation")
plt.xlabel("x")
plt.ylabel("Absolute Error")
plt.legend()
plt.grid(True)
plt.show()

# (b) Hermite Interpolation on [1, 2, 3]
x_b = [1, 2, 3]
y_b = f(np.array(x_b))
dy_b = f_prime(np.array(x_b))

z_b, coef_b = nu.hermite_interpolation(x_b, y_b, dy_b)

print(f"(b) Hermite Polynomial Coefficients: {coef_b}")

approx_b = nu.evaluate_hermite(z_b, coef_b, 1.2)
print(f"(b) Approximation of f(1.2): {approx_b}")

x_dense_b = np.linspace(1, 3, 100)
f_dense_b = f(x_dense_b)
hermite_dense_b = [nu.evaluate_hermite(z_b, coef_b, xi) for xi in x_dense_b]
error_b = np.abs(f_dense_b - hermite_dense_b)

max_error_b = np.max(error_b)
print(f"(b) Maximum error: {max_error_b}")

plt.figure(figsize=(10, 6))
plt.plot(x_dense_b, error_b, label="Error", color="purple")
plt.title("(b) Error for Hermite Degree 5 Interpolation")
plt.xlabel("x")
plt.ylabel("Absolute Error")
plt.legend()
plt.grid(True)
plt.show()

# numerical_utility.py

import numpy as np

def base_points(n, a, b):
    return [a + ((b - a) * i / n) for i in range(n + 1)]


def chebyshev_points(n, a, b):
    return [((a + b) / 2) + ((b - a) / 2)* np.cos((2 * i + 1) * np.pi / (2 * (n + 1))) for i in range(n + 1)]


def cubic_spline_interpolation(x, y):
    n = len(x) - 1
    h = np.diff(x)

    A = np.zeros((n + 1, n + 1))
    B = np.zeros(n + 1)

    A[0, 0] = 1
    A[n, n] = 1

    for i in range(1, n):
        A[i, i-1] = h[i-1]
        A[i, i] = 2 * (h[i-1] + h[i])
        A[i, i+1] = h[i]
        B[i] = 3 * ((y[i+1] - y[i]) / h[i] - (y[i] - y[i-1]) / h[i-1])

    c = np.linalg.solve(A, B)

    b = [(y[i+1] - y[i]) / h[i] - h[i] * (2*c[i] + c[i+1]) / 3 for i in range(n)]
    d = [(c[i+1] - c[i]) / (3*h[i]) for i in range(n)]
    a = y[:-1]

    return a, b, c[:-1], d


def evaluate_spline(x_val, x, a, b, c, d):
    for i in range(len(x) - 1):
        if x[i] <= x_val <= x[i + 1]:
            dx = x_val - x[i]
            return a[i] + b[i] * dx + c[i] * dx**2 + d[i] * dx**3


def clamped_cubic_spline(x, y, der_a, der_b):
    n = len(x) - 1
    h = np.diff(x)

    A = np.zeros((n + 1, n + 1))
    B = np.zeros(n + 1)

    A[0, 0] = 2 * h[0]
    A[0, 1] = h[0]
    B[0] = 3 * ((y[1] - y[0]) / h[0] - der_a)

    A[n, n - 1] = h[-1]
    A[n, n] = 2 * h[-1]
    B[n] = 3 * (der_b - (y[n] - y[n - 1]) / h[-1])

    a, b, c, d = cubic_spline_interpolation(x, y)

    return a, b, c, d


def lagrange_interpolation(xy_points, x, n):
    sorted_points = sorted(xy_points,key=lambda x: x[0])
    result = 0.0
    for i in range(n + 1):
        z = sorted_points[i][1]
        for j in range(n + 1):
            if j!= i:
                z *= (x - sorted_points[j][0]) / (sorted_points[i][0] - sorted_points[j][0])
        result += z
    return result

def divided_differences(x, y):
    n = len(x)
    coef = np.array(y, float)

    for j in range(1, n):
        for i in range(n - 1, j - 1, -1):
            coef[i] = (coef[i] - coef[i - 1]) / (x[i] - x[i - j])
    return coef


def newton_interpolation(x_data, y_data, x):
    coef = divided_differences(x_data, y_data)
    n = len(coef)
    result = coef[-1]

    for i in range(n - 2, -1, -1):
        result = result * (x - x_data[i]) + coef[i]
    return result


def hermite_interpolation(x_val, y_val, y_der):
    n = len(x_val)
    z = np.zeros(2 * n)
    Q = np.zeros((2 * n, 2 * n))

    for i in range(n):
        z[2 * i] = x_val[i]
        z[2 * i + 1] = x_val[i]
        Q[2 * i, 0] = y_val[i]
        Q[2 * i + 1, 0] = y_val[i]
        Q[2 * i + 1, 1] = y_der[i]
        if i != 0:
            Q[2 * i, 1] = (Q[2 * i, 0] - Q[2 * i - 1, 0]) / (z[2 * i] - z[2 * i - 1])

    for j in range(2, 2 * n):
        for i in range(j, 2 * n):
            Q[i, j] = (Q[i, j - 1] - Q[i - 1, j - 1]) / (z[i] - z[i - j])

    return z, Q[0]


def evaluate_hermite(z, coef, x):
    n = len(coef)
    result = coef[0]
    prod = 1
    for i in range(1, n):
        prod *= (x - z[i - 1])
        result += coef[i] * prod
    return result