# -*- coding: utf-8 -*-
"""Atheesh_Krishnan_NA_HW4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KIFazaMLOQ_9mcfqs4bqi101FmnCUhxB
"""

import numpy as np
import pandas as pd
import yfinance as yf

from hw4_utility import *

"""# Q1"""

m1 = np.array([[4, 0, 0, 0],[6, 7, 0, 0],[9, 11, 1, 0],[5, 4, 1, 1]])
m2 = np.array([[2, 3, 1, 2],[-2, 4, -1, 5],[3, 7, 1.5, 1],[6, -9, 3, 7]])

for i, matrix in enumerate([m1, m2], start=1):
    print(f"Matrix {i}:")
    print(f"Symmetric:", check_symmetric(matrix))
    print(f"Singular:", check_singular(matrix))
    print(f"Positive Definite:", check_posdef(matrix))
    print("--------------------")

"""# Q2

### LU Factorization
"""

A = np.array([[4, 1, 1, 1],[1, 3, -1, 1],[1, -1, 2, 0],[1, 1, 0, 2]], dtype=float)

if lu_conditions(A):
    print("LU factorization conditions satisfied.")
    L, U = lu_factorization(A)
    print("\nMatrix A:")
    print(A)
    print("\nLower Triangular Matrix L:")
    print(L)
    print("\nUpper Triangular Matrix U:")
    print(U)
    print("\n(LU):")
    print(L @ U)
    if np.allclose(A, L @ U):
        print("\nLU factorization verified.")
    else:
        print("\nLU factorization failed.")
else:
    print("LU factorization not possibl.e")

"""### LDL^T Factorization"""

A = np.array([[4, 1, 1, 1],[1, 3, -1, 1],[1, -1, 2, 0],[1, 1, 0, 2]], dtype=float)

if ldlt_conditions(A):
    print("LDL^T conditions satisfied.")
    L, D = ldlt_factorization(A)
    print("\nMatrix A:")
    print(A)
    print("\nLower Triangular Matrix L:")
    print(L)
    print("\nDiagonal Matrix D:")
    print(D)
    print("\n(LDL^T):")
    print(L @ D @ L.T)
    if np.allclose(A, L @ D @ L.T):
        print("\nLDL^T factorization verified.")
    else:
        print("\nLDL^T factorization failed.")
else:
    print("LDL^T factorization not possible.")

"""### Cholesky Decomposition"""

A = np.array([[4, 1, 1, 1],[1, 3, -1, 1],[1, -1, 2, 0],[1, 1, 0, 2]], dtype=float)

if cholesky_conditions(A):
    print("Cholesky conditions satisfied.")
    L = cholesky_factorization(A)
    print("\nMatrix A:")
    print(A)
    print("\nLower Triangular Matrix L:")
    print(L)
    print("\nTranspose of Lower Triangular Matrix L.T:")
    print(L.T)
    print("\n(L @ L.T):")
    print(L @ L.T)
    if np.allclose(A, L @ L.T):
        print("\nCholesky factorization verified.")
    else:
        print("\nCholesky factorization failed.")
else:
    print("Cholesky factorization not possible.")

"""# Q3"""

A = np.array([[1, 1, 0, 3],[2, 1, -1, 1],[3, -1, -1, 2],[-1, 2, 3, -1]], dtype=float)
B = np.array([8, 7, 14, -7], dtype=float)
B_systems = [B.copy()]

for i in range(len(B)):
    B2 = B.copy()
    B2[i] *= 1.01
    B_systems.append(B2)

print("Solutions via LU FACTORIZATION:")
print("================")
for i, b in enumerate(B_systems, start=1):
    try:
        X = solve_system(A, b)
        print(f"SYSTEM {i}:")
        print(f"RHS Vector B:{b}")
        print(f"Solution X:{X}\n")
    except ValueError as e:
        print(f"SYSTEM {i}: {e}\n")

print("Solutions via GAUSSIAN ELIMINATION:")
print("======================================")
for i, b in enumerate(B_systems, start=1):
    X = gaussian_elimination(A, b)
    print(f"SYSTEM {i}:")
    print(f"RHS Vector B:{b}")
    print(f"Solution X:{X}\n")

n = A.shape[0]

decomposition_ops = (2 / 3) * n**3
substitution_ops = 10 * n**2
lu_ops = decomposition_ops + substitution_ops

gaussian_ops = (10 / 3) * n**3

print(f"LU Decomposition Total Operations: {lu_ops:.2f}")
print(f"Gaussian Elimination Total Operations: {gaussian_ops:.2f}\n")

if lu_ops < gaussian_ops:
    print("LU decomposition is more efficient for solving multiple systems with the same matrix A.")
else:
    print("Gaussian elimination is more efficient for solving single systems.")

"""# Q4"""

def get_stock_data(tickers, start_date, end_date):
    data = {ticker: yf.download(ticker, start=start_date, end=end_date)['Adj Close'] for ticker in tickers}
    df = pd.concat(data, axis=1, join="inner")
    df.columns = tickers
    df = df.dropna(how="any")
    return df

def analyze_stock_pair(main_ticker, pair_ticker, start_date, end_date):
    tickers = [main_ticker, pair_ticker]
    prices = get_stock_data(tickers, start_date, end_date)
    returns = prices.pct_change().dropna()
    cov_matrix = returns.cov()

    if cholesky_conditions(cov_matrix):
        L = cholesky_factorization(cov_matrix.to_numpy())
        return cov_matrix, True, L
    else:
        return cov_matrix, False, None

start_date = "2024-01-02"
end_date = "2024-11-29"

main_ticker = "JPM"
pair_tickers = ["BAC", "XOM", "AAPL", "CVX"]

for pair_ticker in pair_tickers:
    print(f"\nPair: {main_ticker} and {pair_ticker}\n")
    cov_matrix, cholesky_possible, L = analyze_stock_pair(main_ticker, pair_ticker, start_date, end_date)
    print(f"Covariance Matrix:\n{cov_matrix}\n")
    print(f"Cholesky Decomposition Possible: {cholesky_possible}\n")

    if L is not None:
        print(f"Cholesky Factorization (L):\n{L}")
        print(f"\nReconstructed Covariance Matrix (L * L^T):\n{L @ L.T}")
        print(f"\nOriginal Covariance Matrix:\n{cov_matrix}")
        if np.allclose(cov_matrix.to_numpy(), L @ L.T):
            print("\nVerification Passed.")
        else:
            print("\nVerification Failed.")
        break

"""# Q5"""

A = np.array([[-4, 6],[3, 8]], dtype=float)
U, S, Vt = svd(A)

print("Original Matrix A:")
print(A)
print("\nU (Left Singular Vectors):")
print(U)
print("\nS (Singular Values):")
print(S)
print("\nVt (Right Singular Vectors - Transposed):")
print(Vt)

print("\n(U * S * Vt):")
print(U @ S @ Vt)

if np.allclose(A, U @ S @ Vt):
    print("\nVerification Passed.")
else:
    print("\nVerification Failed.")

"""# Q6"""

A = np.array([[1, -1],[0,  1],[-1, 0]])

eigenvalues, eigenvectors, transformed_data = pca(A)

print("Original Matrix A:")
print(A)
print("\nEigenvalues:")
print(eigenvalues)
print("\nEigenvectors:")
print(eigenvectors)
print("\nPCA Extraction:")
print(transformed_data)